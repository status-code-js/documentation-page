<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@200&display=swap" rel="stylesheet">
    <title>Documentation Page</title>
</head>
<body>

    <div class="container">
        <nav id="navbar" class="navbar">
            <header class="main-header">
                <h1>React JS Concepts</h1>
            </header>
            <div class="nav-list">
                <ul>
                    <li><a class="nav-link" href="#Introducing_JSX">Introducing JSX</a></li>
                    <li><a class="nav-link" href="#Rendering_Elements">Rendering Elements</a></li>
                    <li><a class="nav-link" href="#Components_Props">Components and Props</a></li>
                    <li><a class="nav-link" href="#State_Lifecycle">State and Lifecycle</a></li>
                    <li><a class="nav-link" href="#Handling_Events">Handling Events</a></li>
                    <li><a class="nav-link" href="#Conditional_Rendering">Conditional Rendering</a></li>
                    <li><a class="nav-link" href="#Lists_Keys">Lists and Keys</a></li>
                    <li><a class="nav-link" href="#Forms">Forms</a></li>
                    <li><a class="nav-link" href="#Lifting_State_Up">Lifting State Up</a></li>
                    <li><a class="nav-link" href="#Composition_Inheritance">Composition vs Inheritance</a></li>
                    <li><a class="nav-link" href="#Hooks">Hooks</a></li>
                    <li><a class="nav-link" href="#reference">Reference</a></li>
                </ul>
            </div>
        </nav>

        <main id="main-doc" class="main-doc">
        <div>
        <section id="Introducing_JSX" class="main-section">
            <header id="header_JSX">
                <h3>Introducing JSX</h3>
            </header>
            <div class="text-container">
                <p>React embraces the fact that rendering logic is inherently coupled with other UI logic: how events are handled, how the state changes over time, and how the data is prepared for display.
                Instead of artificially separating technologies by putting markup and logic in separate files, React separates concerns with loosely coupled units called “components” that contain both. We will come back to components in a further section, but if you’re not yet comfortable putting markup in JS, this talk might convince you otherwise.
                React doesn’t require using JSX, but most people find it helpful as a visual aid when working with UI inside the JavaScript code. It also allows React to show more useful error and warning messages.
                In the example below, we declare a variable called name and then use it inside JSX by wrapping it in curly braces:</p>
                <code>const name = 'Josh Perez';
                    const element = &ltdiv&gtHello, {name}&lt/div&gt;
                    
                    ReactDOM.render(
                      element,
                      document.getElementById('root')
                    );
                </code>
            </div>
        </section>

        <section id="Rendering_Elements" class="main-section">
            <header id="header_rendering">
                <h3>Rendering Elements</h3>
            </header>
            <div class="text-container">
                <p>Let’s say there is a &ltdiv&gt somewhere in your HTML file:</p>

                    
                    <code>&ltdiv id="root"&gt&lt/div&gt</code>
                    <p>We call this a “root” DOM node because everything inside it will be managed by React DOM.
                    
                    Applications built with just React usually have a single root DOM node. If you are integrating React into an existing app, you may have as many isolated root DOM nodes as you like.
                    
                    To render a React element into a root DOM node, pass both to ReactDOM.render():</p>
                    
                    <code>const element = &lth1&gtHello, world&lt/h1&gt;
                    ReactDOM.render(element, document.getElementById('root'));</code>
            
                </div>
        </section>

        <section id="Components_Props" class="main-section">
            <header>
                <h3 id="header_components">Components and Props</h3>
            </header>
            <div class="text-container">
                <p>The simplest way to define a component is to write a JavaScript function:

                    <code>function Welcome(props) {
                      return &lth1&gtHello, {props.name}&lt/h1&gt;
                    }</code>
                    This function is a valid React component because it accepts a single “props” (which stands for properties) object argument with data and returns a React element. We call such components “function components” because they are literally JavaScript functions.
                    You can also use an ES6 class to define a component:

                    <code>class Welcome extends React.Component {
                    render() {
                    return &lth1&gtHello, {this.props.name}&lt/h1&gt;
                    }
                }</code>
The above two components are equivalent from React’s point of view.</p>
          </div>
        </section>

        <section id="State_Lifecycle" class="main-section">
            <header id="header_state">
                <h3>State and Lifecycle</h3>
            </header>
            <div class="text-container">
                <p>We will move the date from props to state in three steps:

                    Replace this.props.date with this.state.date in the render() method:
                   <code> class Clock extends React.Component {
                      render() {
                        return (
                            &ltdiv&gt
                            &lth1&gtHello, world!&lt/h1&gt
                            &lth2&gtIt is {this.state.date.toLocaleTimeString()}.&lt/h2&gt
                          &lt/div&gt
                        );
                      }
                    }
                    </code>
                    Add a  class constructor that assigns the initial this.state:
                    <code>class Clock extends React.Component {
                      constructor(props) {
                        super(props);
                        this.state = {date: new Date()};
                      }
                    
                      render() {
                        return (
                            &ltdiv&gt
                            &lth1&gtHello, world!&lt/h1&gt
                            &lth2&gtIt is {this.state.date.toLocaleTimeString()}.&lt/h2&gt
                            &lt/div&gt
                        );
                      }
                    }
                  
                   </code>
                    Note how we pass props to the base constructor:
                    
                      <code>constructor(props) {
                        super(props);
                        this.state = {date: new Date()};
                      }</code>
                    </p>
                </div>
        </section>

        <section id="Handling_Events" class="main-section">
            <header id="header_events">
                <h3>Handling Events</h3>
            </header>
            <div class="text-container">
                <p>When using React, you generally don’t need to call addEventListener to add listeners to a DOM element after it is created. Instead, just provide a listener when the element is initially rendered.

                    When you define a component using an ES6 class, a common pattern is for an event handler to be a method on the class. For example, this Toggle component renders a button that lets the user toggle between “ON” and “OFF” states:</p>
                    <code>class Toggle extends React.Component {
                        constructor(props) {
                          super(props);
                          this.state = {isToggleOn: true};
                      
                          // This binding is necessary to make `this` work in the callback
                          this.handleClick = this.handleClick.bind(this);
                        }
                      
                        handleClick() {
                          this.setState(prevState => ({
                            isToggleOn: !prevState.isToggleOn
                          }));
                        }
                      
                        render() {
                          return (
                            &ltbutton onClick={this.handleClick}&gt
                              {this.state.isToggleOn ? 'ON' : 'OFF'}
                              &lt/button&gt
                          );
                        }
                      }
                      
                      ReactDOM.render(
                        &ltToggle /&gt,
                        document.getElementById('root')
                      );</code>
                    </div>
        </section>

        <section id="Conditional_Rendering" class="main-section">
            <header id="header_conditional">
                <h3>Conditional Rendering</h3>
            </header>
            <div class="text-container">
                <p>In React, you can create distinct components that encapsulate behavior you need. Then, you can render only some of them, depending on the state of your application.

                    Conditional rendering in React works the same way conditions work in JavaScript. Use JavaScript operators like if or the conditional operator to create elements representing the current state, and let React update the UI to match them.</p>
                    <p>Consider these two components:

<code>function UserGreeting(props) {
  return &lth1&gtWelcome back!&lt/h1&gt;
}

function GuestGreeting(props) {
  return &lth1&gtPlease sign up.&lt/h1&gt;
}
</code>
</p>
</div> 
        </section>

        <section id="Lists_Keys" class="main-section">
            <header id="header_lists">
                <h3>Lists and Keys</h3>
            </header>
            <div class="text-container">
                <p>You can build collections of elements and include them in JSX using curly braces {}.

                    Below, we loop through the numbers array using the JavaScript map() function. We return a &ltli&gt element for each item. Finally, we assign the resulting array of elements to listItems:
                    
                   <code>const numbers = [1, 2, 3, 4, 5];
                    const listItems = numbers.map((number) =>
                    &ltli&gt{number}&lt/li&gt
                    );
                </code> 
                    </p>
                </div>
            
        </section>

        <section id="Forms" class="main-section">
            <header id="header_forms">
                <h3>Forms</h3>
            </header>
            <div class="text-container">
                <p>HTML form elements work a bit differently from other DOM elements in React, because form elements naturally keep some internal state. For example, this form in plain HTML accepts a single name:

            <code>   &ltform&gt
                &ltlabel&gt
                        Name:
                        &ltinput type="text" name="name" /&gt
                        &lt/label&gt
                        &ltinput type="submit" value="Submit" /&gt
                        &lt/form&gt
            </code> 
                    This form has the default HTML form behavior of browsing to a new page when the user submits the form. If you want this behavior in React, it just works. But in most cases, it’s convenient to have a JavaScript function that handles the submission of the form and has access to the data that the user entered into the form. The standard way to achieve this is with a technique called “controlled components”.</p>
                </div>
        </section>

        <section id="Lifting_State_Up" class="main-section">
            <header id="header_stateup">
                <h3>Lifting State Up</h3>
            </header>
                <p>Often, several components need to reflect the same changing data. We recommend lifting the shared state up to their closest common ancestor. Let’s see how this works in action.

                    In this section, we will create a temperature calculator that calculates whether the water would boil at a given temperature.
                    
                    We will start with a component called BoilingVerdict. It accepts the celsius temperature as a prop, and prints whether it is enough to boil the water:
                    
                    <code>function BoilingVerdict(props) {
                      if (props.celsius >= 100) {
                        return &ltp&gtThe water would boil.&lt/p&gt;
                      }
                      return &ltp&gtThe water would not boil.&lt/p&gt;
                    }
                </code>
                </p>
            
        </section>

        <section id="Composition_Inheritance" class="main-section">
            <header id="header_composition">
                <h3>Composition vs Inheritance</h3>
            </header>
            <div class="text-container">
                <p>React has a powerful composition model, and we recommend using composition instead of inheritance to reuse code between components.</p>
                <p>Some components don’t know their children ahead of time. This is especially common for components like Sidebar or Dialog that represent generic “boxes”.

                    We recommend that such components use the special children prop to pass children elements directly into their output:</p>
                    <code>function FancyBorder(props) {
                        return (
                            &ltdiv className={'FancyBorder FancyBorder-' + props.color}&gt
                            {props.children}
                            &lt/div&gt
                        );
                      }</code>
                    </div>
        </section>

        <section id="Hooks" class="main-section">
            <header id="header_hooks">
                <h3>Hooks</h3>
            </header>
            <div class="text-container">
                <p>Hooks are functions that let you “hook into” React state and lifecycle features from function components. Hooks don’t work inside classes — they let you use React without classes. (We don’t recommend rewriting your existing components overnight but you can start using Hooks in the new ones if you’d like.)

                    React provides a few built-in Hooks like useState. You can also create your own Hooks to reuse stateful behavior between different components. We’ll look at the built-in Hooks first.</p>
                    <p>This example renders a counter. When you click the button, it increments the value:</p>
                    <code>import React, { useState } from 'react';

                        function Example() {
                          // Declare a new state variable, which we'll call "count"
                          const [count, setCount] = useState(0);
                        
                          return (
                            &ltdiv&gt
                            &ltp&gtYou clicked {count} times&lt/p&gt
                            &ltbutton onClick={() => setCount(count + 1)}&gt
                                Click me
                                &lt/button&gt
                                &lt/div&gt
                          );
                        }</code>
                        <p>Here, useState is a Hook. We call it inside a function component to add some local state to it. React will preserve this state between re-renders. useState returns a pair: the current state value and a function that lets you update it. You can call this function from an event handler or somewhere else. It’s similar to this.setState in a class, except it doesn’t merge the old and new state together.</p>
                    </div>
        </section>

        <section id="reference" class="main-section">
            <header id="reference-header">
                <h3>Reference</h3>
            </header>
            <div class="text-container">
                <p>All the documentation in this page is taken from <a href="https://ru.reactjs.org/" target="_blank">React JS</a></p>
            </div>
        </section>
    </div>

  </div>
    </main> 


</body>
</html>